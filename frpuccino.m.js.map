{"version":3,"file":"frpuccino.m.js","sources":["src/lib/event-list.ts","src/lib/browser.ts","src/lib/record-application.ts"],"sourcesContent":["// this is not comprehensive yet, just alot of busywork to add the rest\r\n// https://developer.mozilla.org/en-US/docs/Web/Events\r\nexport default {\r\n  // form events\r\n  onblur: 'blur',\r\n  onchange: 'change',\r\n  oncontextmenu: 'contextmenu',\r\n  onfocus: 'focus',\r\n  oninput: 'input',\r\n  oninvalid: 'invalid',\r\n  onreset: 'reset',\r\n  onsearch: 'search',\r\n  onselect: 'select',\r\n  onsubmit: 'submit',\r\n  // keyboard events\r\n  onkeydown: 'keydown',\r\n  onkeypress: 'keypress',\r\n  onkeyup: 'keyup',\r\n  // mouse events\r\n  onclick: 'click',\r\n  ondblclick: 'dblclick',\r\n  onmousedown: 'mousedown',\r\n  onmousemove: 'mousemove',\r\n  onmouseout: 'mouseout',\r\n  onmouseover: 'mouseover',\r\n  onmouseup: 'mouseup',\r\n  onwheel: 'wheel',\r\n  // animation\r\n  onanimationend: 'animationend',\r\n  onanimationstart: 'animationstart',\r\n  // drag events\r\n  ondrag: 'drag',\r\n  ondragend: 'dragend',\r\n  ondragenter: 'dragenter',\r\n  ondragexit: 'dragexit',\r\n  ondragleave: 'dragleave',\r\n  ondragover: 'dragover',\r\n  ondragstop: 'dragstop',\r\n  ondrop: 'drop'\r\n}\r\n","import {\r\n  startWith,\r\n  loop,\r\n  empty,\r\n  merge,\r\n  mergeArray,\r\n  map,\r\n  take,\r\n  propagateEventTask,\r\n  now\r\n} from '@most/core'\r\nimport updateDOM from 'morphdom'\r\nimport mitt from 'mitt'\r\nimport {\r\n  Stream,\r\n  Sink,\r\n  Scheduler,\r\n  Disposable,\r\n  Task,\r\n  ScheduledTask\r\n} from '@most/types'\r\nimport {\r\n  newDefaultScheduler,\r\n  cancelAllTasks,\r\n  asap,\r\n  newTimeline,\r\n  delay\r\n} from '@most/scheduler'\r\nimport eventList from './event-list'\r\nimport { StreamAttributes } from './attributes'\r\n\r\nexport type Emitter = mitt.Emitter;\r\n\r\nexport const ACTION = 'ACTION'\r\n\r\nexport interface StreamElement<Action> extends Element {\r\n  eventStream?: Stream<Action>;\r\n}\r\n\r\nfunction cloneEventStream(el: Element, source: Element): Stream<any> {\r\n  const eventStreams: Stream<any>[] = []\r\n  Object.keys(eventList).forEach((eventName) => {\r\n    if (source[eventName] && source[eventName].mapFn) {\r\n      const mapEvent = source[eventName].mapFn\r\n\r\n      eventStreams.push(\r\n        map(\r\n          mapEvent,\r\n          fromDOMEvent(eventName, el, mapEvent)\r\n        )\r\n      )\r\n    }\r\n  })\r\n\r\n  let eventStream = mergeArray(eventStreams)\r\n\r\n  for (let i = 0; i < el.children.length; i++) {\r\n    const child = el.children[i]\r\n    const sourceChild = source.children[i]\r\n    eventStream = merge(\r\n      eventStream,\r\n      cloneEventStream(child, sourceChild)\r\n    )\r\n  }\r\n\r\n  return eventStream\r\n}\r\n\r\nexport function cloneNode<a>(): StreamElement<any> {\r\n  const toNode: StreamElement<a> = this\r\n  const fromNode = document.createElement('div')\r\n\r\n  updateDOM(fromNode, Element.prototype.cloneNode.call(toNode, true))\r\n\r\n  return (fromNode as StreamElement<any>)\r\n}\r\n\r\nexport function mapElement<a, b>(mapFn: (from: a) => b, toNode: StreamElement<a>): StreamElement<b> {\r\n  const next: StreamElement<a | b> = cloneNode.call(toNode)\r\n\r\n  next.eventStream = map(mapFn, cloneEventStream(next, toNode))\r\n\r\n  return next\r\n}\r\n\r\nexport interface TimedAction<Action> {\r\n  time?: number;\r\n  action?: Action;\r\n}\r\n\r\nexport type TaskCreator<Action> = (\r\n  sink: ApplicationSink<Action>,\r\n  scheduler: Scheduler\r\n) => ScheduledTask;\r\n\r\nexport type UpdateResult<Model, Action> =\r\n  | Model \r\n  | [Model, TaskCreator<Action> | TaskCreator<Action>[]]\r\n\r\nexport interface ApplicationConfig<Action, Model> {\r\n  mount: Element;\r\n  init: Model;\r\n  update: (\r\n    model: Model,\r\n    action: Action,\r\n    scheduler: Scheduler\r\n  ) => UpdateResult<Model, Action>;\r\n  view: (model: Model) => StreamElement<Action>;\r\n  scheduler?: Scheduler;\r\n  runTasks?: boolean;\r\n}\r\n\r\nexport type ApplicationStream<Action> = Stream<ApplicationEvent<Action>>;\r\n\r\nexport type ApplicationSink<Action> = Sink<TimedAction<Action> | ApplicationEvent<Action>>;\r\n\r\nexport interface ApplicationEvent<Action> {\r\n  view?: Element;\r\n  task?: TaskCreator<Action> | TaskCreator<Action>[];\r\n  eventStream: Stream<TimedAction<Action>>;\r\n}\r\n\r\nexport function createApplication<Model, Action>(\r\n  applicationConfig: ApplicationConfig<Action, Model>\r\n): {\r\n  applicationStream: ApplicationStream<Action>;\r\n  applicationSink: ApplicationSink<Action>;\r\n  scheduler: Scheduler;\r\n  run: (action: Action) => Disposable;\r\n  eventSource: mitt.Emitter;\r\n} {\r\n  const { mount, init, update, view, runTasks } = applicationConfig\r\n\r\n  const scheduler = applicationConfig.scheduler || newDefaultScheduler()\r\n\r\n  const eventSource = mitt()\r\n  const eventStream: Stream<TimedAction<Action>> = {\r\n    run: (sink, scheduler) => {\r\n      const handleMsg = action => sink.event(scheduler.currentTime(), action)\r\n      eventSource.on(ACTION, handleMsg)\r\n      return {\r\n        dispose: () => {\r\n          eventSource.off(ACTION, handleMsg)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const applicationStream: Stream<{\r\n    view: Element;\r\n    task?: TaskCreator<Action> | TaskCreator<Action>[];\r\n    eventStream: Stream<TimedAction<Action>>;\r\n  }> = loop(\r\n    (model: Model, timedAction: TimedAction<Action>) => {\r\n      let task\r\n      let nextModel\r\n\r\n      const updateResult = update(model, timedAction.action, scheduler)\r\n      if (\r\n        Array.isArray(updateResult)\r\n      ) {\r\n        [nextModel, task] = updateResult\r\n      } else {\r\n        nextModel = updateResult\r\n      }\r\n\r\n      console.log({nextModel, task, updateResult})\r\n\r\n      const nextView: StreamElement<Action> = view(nextModel)\r\n\r\n      return {\r\n        seed: nextModel,\r\n        value: {\r\n          view: nextView,\r\n          task,\r\n          eventStream: take(\r\n            1,\r\n            map(action => ({ action }), nextView.eventStream)\r\n          )\r\n        }\r\n      }\r\n    },\r\n    init,\r\n    eventStream\r\n  )\r\n\r\n  const applicationSink: Sink<Action | ApplicationEvent<Action>> = {\r\n    event: function (time, event_) {\r\n      const action = isAction(event_)\r\n        ? event_\r\n        : null\r\n\r\n      if (action) {\r\n        const applicationEvent: ApplicationEvent<Action> = { \r\n          eventStream: now(action)\r\n        }\r\n        return this.event.call(this, time, applicationEvent)\r\n      }\r\n\r\n      const event = event_ as ApplicationEvent<Action>\r\n      if (event.view) {\r\n        updateDOM(mount, event.view, { onBeforeElUpdated })\r\n      }\r\n\r\n      if (event.task && runTasks !== false) {\r\n        const tasks = Array.isArray(event.task) ? event.task : [event.task]\r\n        const timeline = newTimeline()\r\n\r\n        tasks.forEach(t => {\r\n          const task = t(applicationSink, scheduler)\r\n          timeline.add(task)\r\n        })\r\n        timeline.runTasks(0, t => t.run())\r\n      }\r\n\r\n      const disposable = event.eventStream.run(\r\n        {\r\n          event: (time, timedAction) => {\r\n            if (!timedAction.time) {\r\n              timedAction.time = time\r\n            }\r\n            eventSource.emit(ACTION, timedAction)\r\n          },\r\n          end: () => {\r\n            disposable.dispose()\r\n          },\r\n          error: (_, err) => {\r\n            console.error(err)\r\n            throw err\r\n          }\r\n        },\r\n        scheduler\r\n      )\r\n    },\r\n    end: () => { },\r\n    error: (_, err) => {\r\n      console.error(err)\r\n      throw err\r\n    }\r\n  }\r\n\r\n  return {\r\n    applicationStream,\r\n    applicationSink,\r\n    scheduler,\r\n    eventSource,\r\n    run: (action: Action) => {\r\n      const disposable = applicationStream.run(applicationSink, scheduler)\r\n\r\n      eventSource.emit(ACTION, { time: scheduler.currentTime(), action })\r\n\r\n      return disposable\r\n    }\r\n  }\r\n}\r\n\r\nfunction fromDOMEvent<Action>(\r\n  event, \r\n  target: Element,\r\n  mapFn: (Event) => Action\r\n): Stream<Event> {\r\n  // we need to bind this to the element _immediately_ or else this\r\n  // won't be here for morphdoms onBeforeElUpdated hook\r\n  let sink\r\n  let scheduler\r\n\r\n  if (target) {\r\n    target[event] = (e: Event) => {\r\n      if (sink) sink.event(scheduler.currentTime(), e)\r\n    }\r\n    target[event].mapFn = mapFn\r\n  }\r\n\r\n  return {\r\n    run: (_sink, _scheduler) => {\r\n      sink = _sink\r\n      scheduler = _scheduler\r\n\r\n      return {\r\n        dispose: () => {\r\n          sink = undefined\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function createElement<Action>(\r\n  tag: string,\r\n  attributes: StreamAttributes<Action>,\r\n  ...children\r\n): StreamElement<Action> {\r\n  const el: StreamElement<Action> = document.createElement(tag)\r\n\r\n  el.eventStream = empty()\r\n\r\n  if (attributes) {\r\n    Object.keys(attributes).forEach(function (name) {\r\n      const val = attributes[name]\r\n      if (eventList[name] && val) {\r\n        const mapEvent = val.constructor === Function ? val : () => val\r\n        el.eventStream = merge(\r\n          el.eventStream,\r\n          map(\r\n            mapEvent,\r\n            fromDOMEvent(name, el, mapEvent)\r\n          )\r\n        )\r\n        return\r\n      }\r\n      if (['className', 'id'].indexOf(name) !== -1) {\r\n        el[name] = val\r\n        return\r\n      }\r\n\r\n      if (typeof val === 'undefined' || val === null) {\r\n        return\r\n      }\r\n      el.setAttribute(name, val)\r\n    })\r\n  }\r\n\r\n  children.forEach(function appendChild(child) {\r\n    if (typeof child === 'number') {\r\n      const textNode = document.createTextNode(child.toString())\r\n      el.appendChild(textNode)\r\n      return\r\n    }\r\n\r\n    if (!child) {\r\n      return\r\n    }\r\n\r\n    if (child && child.constructor === String) {\r\n      const textNode = document.createTextNode(child)\r\n      el.appendChild(textNode)\r\n      return\r\n    }\r\n\r\n    if (Array.isArray(child)) {\r\n      child.forEach(appendChild)\r\n      return\r\n    }\r\n\r\n    el.appendChild(child)\r\n\r\n    el.eventStream = merge(el.eventStream, child.eventStream)\r\n    el.cloneNode = cloneNode\r\n    child.eventStream = null\r\n  })\r\n\r\n  return el\r\n}\r\n\r\nexport function render(target, elementTree) {\r\n  if (target.children.length === 0) {\r\n    target.appendChild(elementTree)\r\n  }\r\n  const treeRoot = target.children[0]\r\n  updateDOM(treeRoot, elementTree, { onBeforeElUpdated })\r\n}\r\n\r\n// morphdom does not copy over event handlers so they need to be re-bound\r\nfunction onBeforeElUpdated(fromEl: Element, toEl: Element): boolean {\r\n  Object.keys(eventList).forEach(eventHandler => {\r\n    if (toEl[eventHandler]) {\r\n      fromEl[eventHandler] = toEl[eventHandler]\r\n    } else if (fromEl[eventHandler]) {\r\n      fromEl[eventHandler] = undefined\r\n    }\r\n  })\r\n  return true\r\n}\r\n\r\nfunction isAction<Action>(\r\n  sut: TimedAction<Action> | ApplicationEvent<Action>\r\n): sut is TimedAction<Action> {\r\n  const applicationEvent = sut as ApplicationEvent<Action>\r\n  return !applicationEvent.eventStream\r\n}","import {\r\n  createApplication,\r\n  Emitter,\r\n  ACTION,\r\n  TimedAction\r\n} from '../lib/browser'\r\nimport { Scheduler } from '@most/types'\r\nimport { schedulerRelativeTo, delay, asap } from '@most/scheduler'\r\nimport { propagateEventTask, now, at, merge, mergeArray } from '@most/core'\r\n\r\nexport function record<Model, Action>(emitter: Emitter, scheduler: Scheduler) {\r\n  let startTime\r\n  const actions = []\r\n\r\n  const handleAction = (timedAction: TimedAction<Action>) => {\r\n    if (!startTime && timedAction.time) startTime = timedAction.time - 500\r\n    actions.push(timedAction)\r\n  }\r\n\r\n  emitter.on(ACTION, handleAction)\r\n\r\n  return function playback({ mount, update, view, init }) {\r\n    emitter.off(ACTION, handleAction)\r\n\r\n    const replayScheduler = schedulerRelativeTo(\r\n      (startTime - scheduler.currentTime()) * -1,\r\n      scheduler\r\n    )\r\n\r\n    const { applicationSink, applicationStream } = createApplication({\r\n      view,\r\n      update,\r\n      init,\r\n      mount,\r\n      scheduler: replayScheduler,\r\n      runTasks: false\r\n    })\r\n\r\n    const eventStream = mergeArray(actions.map((action) => {\r\n      return at(action.time, action)\r\n    }))\r\n\r\n    merge(applicationStream, eventStream).run(applicationSink, replayScheduler)\r\n  }\r\n}\r\n"],"names":["onblur","onchange","oncontextmenu","onfocus","oninput","oninvalid","onreset","onsearch","onselect","onsubmit","onkeydown","onkeypress","onkeyup","onclick","ondblclick","onmousedown","onmousemove","onmouseout","onmouseover","onmouseup","onwheel","onanimationend","onanimationstart","ondrag","ondragend","ondragenter","ondragexit","ondragleave","ondragover","ondragstop","ondrop","ACTION","cloneNode","fromNode","document","createElement","updateDOM","Element","prototype","call","this","mapElement","mapFn","toNode","next","eventStream","map","cloneEventStream","el","source","eventStreams","Object","keys","eventList","forEach","eventName","mapEvent","push","fromDOMEvent","mergeArray","i","children","length","merge","createApplication","applicationConfig","scheduler","newDefaultScheduler","eventSource","mitt","applicationStream","loop","model","timedAction","task","nextModel","updateResult","update","action","Array","isArray","console","log","nextView","view","seed","value","take","init","run","sink","handleMsg","event","currentTime","on","dispose","off","applicationSink","time","event_","applicationEvent","now","mount","onBeforeElUpdated","runTasks","tasks","timeline","newTimeline","t","add","disposable","emit","end","error","_","err","target","e","_sink","_scheduler","undefined","tag","attributes","empty","name","val","constructor","Function","indexOf","setAttribute","appendChild","child","String","textNode","createTextNode","toString","render","elementTree","fromEl","toEl","eventHandler","record","emitter","startTime","actions","handleAction","ref","replayScheduler","schedulerRelativeTo","at"],"mappings":"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"}