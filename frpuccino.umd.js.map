{"version":3,"file":"frpuccino.umd.js","sources":["src/lib/event-list.ts","src/lib/browser.ts","src/lib/record-application.ts"],"sourcesContent":["// this is not comprehensive yet, just alot of busywork to add the rest\r\n// https://developer.mozilla.org/en-US/docs/Web/Events\r\nexport default {\r\n  // form events\r\n  onblur: 'blur',\r\n  onchange: 'change',\r\n  oncontextmenu: 'contextmenu',\r\n  onfocus: 'focus',\r\n  oninput: 'input',\r\n  oninvalid: 'invalid',\r\n  onreset: 'reset',\r\n  onsearch: 'search',\r\n  onselect: 'select',\r\n  onsubmit: 'submit',\r\n  // keyboard events\r\n  onkeydown: 'keydown',\r\n  onkeypress: 'keypress',\r\n  onkeyup: 'keyup',\r\n  // mouse events\r\n  onclick: 'click',\r\n  ondblclick: 'dblclick',\r\n  onmousedown: 'mousedown',\r\n  onmousemove: 'mousemove',\r\n  onmouseout: 'mouseout',\r\n  onmouseover: 'mouseover',\r\n  onmouseup: 'mouseup',\r\n  onwheel: 'wheel',\r\n  // animation\r\n  onanimationend: 'animationend',\r\n  onanimationstart: 'animationstart',\r\n  // drag events\r\n  ondrag: 'drag',\r\n  ondragend: 'dragend',\r\n  ondragenter: 'dragenter',\r\n  ondragexit: 'dragexit',\r\n  ondragleave: 'dragleave',\r\n  ondragover: 'dragover',\r\n  ondragstop: 'dragstop',\r\n  ondrop: 'drop'\r\n}\r\n","import {\r\n  startWith,\r\n  loop,\r\n  empty,\r\n  merge,\r\n  mergeArray,\r\n  map,\r\n  take,\r\n  propagateEventTask,\r\n  now\r\n} from '@most/core'\r\nimport updateDOM from 'morphdom'\r\nimport mitt from 'mitt'\r\nimport {\r\n  Stream,\r\n  Sink,\r\n  Scheduler,\r\n  Disposable,\r\n  Task,\r\n  ScheduledTask\r\n} from '@most/types'\r\nimport {\r\n  newDefaultScheduler,\r\n  cancelAllTasks,\r\n  asap,\r\n  newTimeline,\r\n  delay\r\n} from '@most/scheduler'\r\nimport eventList from './event-list'\r\nimport { StreamAttributes } from './attributes'\r\n\r\nexport type Emitter = mitt.Emitter;\r\n\r\nexport const ACTION = 'ACTION'\r\n\r\nexport interface StreamElement<Action> extends Element {\r\n  eventStream?: Stream<Action>;\r\n}\r\n\r\nfunction cloneEventStream(el: Element, source: Element): Stream<any> {\r\n  const eventStreams: Stream<any>[] = []\r\n  Object.keys(eventList).forEach((eventName) => {\r\n    if (source[eventName] && source[eventName].mapFn) {\r\n      const mapEvent = source[eventName].mapFn\r\n\r\n      eventStreams.push(\r\n        map(\r\n          mapEvent,\r\n          fromDOMEvent(eventName, el, mapEvent)\r\n        )\r\n      )\r\n    }\r\n  })\r\n\r\n  let eventStream = mergeArray(eventStreams)\r\n\r\n  for (let i = 0; i < el.children.length; i++) {\r\n    const child = el.children[i]\r\n    const sourceChild = source.children[i]\r\n    eventStream = merge(\r\n      eventStream,\r\n      cloneEventStream(child, sourceChild)\r\n    )\r\n  }\r\n\r\n  return eventStream\r\n}\r\n\r\nexport function cloneNode<a>(): StreamElement<any> {\r\n  const toNode: StreamElement<a> = this\r\n  const fromNode = document.createElement('div')\r\n\r\n  updateDOM(fromNode, Element.prototype.cloneNode.call(toNode, true))\r\n\r\n  return (fromNode as StreamElement<any>)\r\n}\r\n\r\nexport function mapElement<a, b>(mapFn: (from: a) => b, toNode: StreamElement<a>): StreamElement<b> {\r\n  const next: StreamElement<a | b> = cloneNode.call(toNode)\r\n\r\n  next.eventStream = map(mapFn, cloneEventStream(next, toNode))\r\n\r\n  return next\r\n}\r\n\r\nexport interface TimedAction<Action> {\r\n  time?: number;\r\n  action?: Action;\r\n}\r\n\r\nexport type TaskCreator<Action> = (\r\n  sink: Sink<{ eventStream: Stream<TimedAction<Action>> }>,\r\n  scheduler: Scheduler\r\n) => ScheduledTask;\r\n\r\nexport type UpdateResult<Model, Action> =\r\n  | Model \r\n  | [Model, TaskCreator<Action> | TaskCreator<Action>[]]\r\n\r\nexport interface ApplicationConfig<Action, Model> {\r\n  mount: Element;\r\n  init: Model;\r\n  update: (\r\n    model: Model,\r\n    action: Action,\r\n    scheduler: Scheduler\r\n  ) => UpdateResult<Model, Action>;\r\n  view: (model: Model) => StreamElement<Action>;\r\n  scheduler?: Scheduler;\r\n  runTasks?: boolean;\r\n}\r\n\r\nexport type ApplicationStream<Action> = Stream<ApplicationEvent<Action>>;\r\n\r\nexport type ApplicationSink<Action> = Sink<TimedAction<Action> | ApplicationEvent<Action>>;\r\n\r\nexport interface ApplicationEvent<Action> {\r\n  view?: Element;\r\n  task?: TaskCreator<Action> | TaskCreator<Action>[];\r\n  eventStream: Stream<TimedAction<Action>>;\r\n}\r\n\r\nexport function createApplication<Model, Action>(\r\n  applicationConfig: ApplicationConfig<Action, Model>\r\n): {\r\n  applicationStream: ApplicationStream<Action>;\r\n  applicationSink: ApplicationSink<Action>;\r\n  scheduler: Scheduler;\r\n  run: (action: Action) => Disposable;\r\n  eventSource: mitt.Emitter;\r\n} {\r\n  const { mount, init, update, view, runTasks } = applicationConfig\r\n\r\n  const scheduler = applicationConfig.scheduler || newDefaultScheduler()\r\n\r\n  const eventSource = mitt()\r\n  const eventStream: Stream<TimedAction<Action>> = {\r\n    run: (sink, scheduler) => {\r\n      const handleMsg = action => sink.event(scheduler.currentTime(), action)\r\n      eventSource.on(ACTION, handleMsg)\r\n      return {\r\n        dispose: () => {\r\n          eventSource.off(ACTION, handleMsg)\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  const applicationStream: Stream<{\r\n    view: Element;\r\n    task?: TaskCreator<Action> | TaskCreator<Action>[];\r\n    eventStream: Stream<TimedAction<Action>>;\r\n  }> = loop(\r\n    (model: Model, timedAction: TimedAction<Action>) => {\r\n      let task\r\n      let nextModel\r\n\r\n      const updateResult = update(model, timedAction.action, scheduler)\r\n      if (\r\n        Array.isArray(updateResult) &&\r\n        typeof updateResult[1] === 'function'\r\n      ) {\r\n        [nextModel, task] = updateResult\r\n      } else {\r\n        nextModel = updateResult\r\n      }\r\n\r\n      const nextView: StreamElement<Action> = view(nextModel)\r\n\r\n      return {\r\n        seed: nextModel,\r\n        value: {\r\n          view: nextView,\r\n          task,\r\n          eventStream: take(\r\n            1,\r\n            map(action => ({ action }), nextView.eventStream)\r\n          )\r\n        }\r\n      }\r\n    },\r\n    init,\r\n    eventStream\r\n  )\r\n\r\n  const applicationSink: Sink<Action | ApplicationEvent<Action>> = {\r\n    event: function (time, event_) {\r\n      const action = isAction(event_)\r\n        ? event_\r\n        : null\r\n\r\n      if (action) {\r\n        const applicationEvent: ApplicationEvent<Action> = { \r\n          eventStream: now(action)\r\n        }\r\n        return this.event.call(this, time, applicationEvent)\r\n      }\r\n\r\n      const event = event_ as ApplicationEvent<Action>\r\n      if (event.view) {\r\n        updateDOM(mount, event.view, { onBeforeElUpdated })\r\n      }\r\n\r\n      if (event.task && runTasks !== false) {\r\n        const tasks = Array.isArray(event.task) ? event.task : [event.task]\r\n        const timeline = newTimeline()\r\n\r\n        tasks.forEach(t => {\r\n          const task = t(applicationSink, scheduler)\r\n          timeline.add(task)\r\n        })\r\n        timeline.runTasks(0, t => t.run())\r\n      }\r\n\r\n      const disposable = event.eventStream.run(\r\n        {\r\n          event: (time, timedAction) => {\r\n            if (!timedAction.time) {\r\n              timedAction.time = time\r\n            }\r\n            eventSource.emit(ACTION, timedAction)\r\n          },\r\n          end: () => {\r\n            disposable.dispose()\r\n          },\r\n          error: (_, err) => {\r\n            console.error(err)\r\n            throw err\r\n          }\r\n        },\r\n        scheduler\r\n      )\r\n    },\r\n    end: () => { },\r\n    error: (_, err) => {\r\n      console.error(err)\r\n      throw err\r\n    }\r\n  }\r\n\r\n  return {\r\n    applicationStream,\r\n    applicationSink,\r\n    scheduler,\r\n    eventSource,\r\n    run: (action: Action) => {\r\n      const disposable = applicationStream.run(applicationSink, scheduler)\r\n\r\n      eventSource.emit(ACTION, { time: scheduler.currentTime(), action })\r\n\r\n      return disposable\r\n    }\r\n  }\r\n}\r\n\r\nfunction fromDOMEvent<Action>(\r\n  event, \r\n  target: Element,\r\n  mapFn: (Event) => Action\r\n): Stream<Event> {\r\n  // we need to bind this to the element _immediately_ or else this\r\n  // won't be here for morphdoms onBeforeElUpdated hook\r\n  let sink\r\n  let scheduler\r\n\r\n  if (target) {\r\n    target[event] = (e: Event) => {\r\n      if (sink) sink.event(scheduler.currentTime(), e)\r\n    }\r\n    target[event].mapFn = mapFn\r\n  }\r\n\r\n  return {\r\n    run: (_sink, _scheduler) => {\r\n      sink = _sink\r\n      scheduler = _scheduler\r\n\r\n      return {\r\n        dispose: () => {\r\n          sink = undefined\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nexport function createElement<Action>(\r\n  tag: string,\r\n  attributes: StreamAttributes<Action>,\r\n  ...children\r\n): StreamElement<Action> {\r\n  const el: StreamElement<Action> = document.createElement(tag)\r\n\r\n  el.eventStream = empty()\r\n\r\n  if (attributes) {\r\n    Object.keys(attributes).forEach(function (name) {\r\n      const val = attributes[name]\r\n      if (eventList[name] && val) {\r\n        const mapEvent = val.constructor === Function ? val : () => val\r\n        el.eventStream = merge(\r\n          el.eventStream,\r\n          map(\r\n            mapEvent,\r\n            fromDOMEvent(name, el, mapEvent)\r\n          )\r\n        )\r\n        return\r\n      }\r\n      if (['className', 'id'].indexOf(name) !== -1) {\r\n        el[name] = val\r\n        return\r\n      }\r\n\r\n      if (typeof val === 'undefined' || val === null) {\r\n        return\r\n      }\r\n      el.setAttribute(name, val)\r\n    })\r\n  }\r\n\r\n  children.forEach(function appendChild(child) {\r\n    if (typeof child === 'number') {\r\n      const textNode = document.createTextNode(child.toString())\r\n      el.appendChild(textNode)\r\n      return\r\n    }\r\n\r\n    if (!child) {\r\n      return\r\n    }\r\n\r\n    if (child && child.constructor === String) {\r\n      const textNode = document.createTextNode(child)\r\n      el.appendChild(textNode)\r\n      return\r\n    }\r\n\r\n    if (Array.isArray(child)) {\r\n      child.forEach(appendChild)\r\n      return\r\n    }\r\n\r\n    el.appendChild(child)\r\n\r\n    el.eventStream = merge(el.eventStream, child.eventStream)\r\n    el.cloneNode = cloneNode\r\n    child.eventStream = null\r\n  })\r\n\r\n  return el\r\n}\r\n\r\nexport function render(target, elementTree) {\r\n  if (target.children.length === 0) {\r\n    target.appendChild(elementTree)\r\n  }\r\n  const treeRoot = target.children[0]\r\n  updateDOM(treeRoot, elementTree, { onBeforeElUpdated })\r\n}\r\n\r\n// morphdom does not copy over event handlers so they need to be re-bound\r\nfunction onBeforeElUpdated(fromEl: Element, toEl: Element): boolean {\r\n  Object.keys(eventList).forEach(eventHandler => {\r\n    if (toEl[eventHandler]) {\r\n      fromEl[eventHandler] = toEl[eventHandler]\r\n    } else if (fromEl[eventHandler]) {\r\n      fromEl[eventHandler] = undefined\r\n    }\r\n  })\r\n  return true\r\n}\r\n\r\nfunction isAction<Action>(\r\n  sut: TimedAction<Action> | ApplicationEvent<Action>\r\n): sut is TimedAction<Action> {\r\n  const applicationEvent = sut as ApplicationEvent<Action>\r\n  return !applicationEvent.eventStream\r\n}","import {\r\n  createApplication,\r\n  Emitter,\r\n  ACTION,\r\n  TimedAction\r\n} from '../lib/browser'\r\nimport { Scheduler } from '@most/types'\r\nimport { schedulerRelativeTo, delay, asap } from '@most/scheduler'\r\nimport { propagateEventTask, now, at, merge, mergeArray } from '@most/core'\r\n\r\nexport function record<Model, Action>(emitter: Emitter, scheduler: Scheduler) {\r\n  let startTime\r\n  const actions = []\r\n\r\n  const handleAction = (timedAction: TimedAction<Action>) => {\r\n    if (!startTime && timedAction.time) startTime = timedAction.time - 500\r\n    actions.push(timedAction)\r\n  }\r\n\r\n  emitter.on(ACTION, handleAction)\r\n\r\n  return function playback({ mount, update, view, init }) {\r\n    emitter.off(ACTION, handleAction)\r\n\r\n    const replayScheduler = schedulerRelativeTo(\r\n      (startTime - scheduler.currentTime()) * -1,\r\n      scheduler\r\n    )\r\n\r\n    const { applicationSink, applicationStream } = createApplication({\r\n      view,\r\n      update,\r\n      init,\r\n      mount,\r\n      scheduler: replayScheduler,\r\n      runTasks: false\r\n    })\r\n\r\n    const eventStream = mergeArray(actions.map((action) => {\r\n      return at(action.time, action)\r\n    }))\r\n\r\n    merge(applicationStream, eventStream).run(applicationSink, replayScheduler)\r\n  }\r\n}\r\n"],"names":["onblur","onchange","oncontextmenu","onfocus","oninput","oninvalid","onreset","onsearch","onselect","onsubmit","onkeydown","onkeypress","onkeyup","onclick","ondblclick","onmousedown","onmousemove","onmouseout","onmouseover","onmouseup","onwheel","onanimationend","onanimationstart","ondrag","ondragend","ondragenter","ondragexit","ondragleave","ondragover","ondragstop","ondrop","ACTION","cloneNode","fromNode","document","createElement","updateDOM","Element","prototype","call","this","createApplication","applicationConfig","scheduler","newDefaultScheduler","eventSource","mitt","applicationStream","loop","model","timedAction","task","nextModel","updateResult","update","action","Array","isArray","nextView","view","seed","value","eventStream","take","map","init","run","sink","handleMsg","event","currentTime","on","dispose","off","applicationSink","time","event_","applicationEvent","now","mount","onBeforeElUpdated","runTasks","tasks","timeline","newTimeline","forEach","t","add","disposable","emit","end","error","_","err","console","fromDOMEvent","target","mapFn","e","_sink","_scheduler","undefined","fromEl","toEl","Object","keys","eventList","eventHandler","toNode","next","cloneEventStream","el","source","eventStreams","eventName","mapEvent","push","mergeArray","i","children","length","merge","tag","attributes","empty","name","val","constructor","Function","indexOf","setAttribute","appendChild","child","String","textNode","createTextNode","toString","elementTree","emitter","startTime","actions","handleAction","ref","replayScheduler","schedulerRelativeTo","at"],"mappings":"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"}